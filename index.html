<!DOCTYPE html>
<!--
Turfmapp Interactive Portfolio
==============================

Interactive map-based portfolio showcasing projects with camera controls.

Features:
- 12.5% zoom into the center of the map initially
- Camera panning controls (drag and edge movement)
- Smooth camera movement with mouse/touch drag
- Tooltip system for interactive project elements
- Admin panel for content management

Controls:
- Mouse/Touch drag to pan camera around the world
- Move cursor to screen edges for automatic camera movement
- Click hotspots to view project details

Debug Mode: Press 'D' to show camera position
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turfmapp Interactive Portfolio</title>
    <style>
        /* CSS Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* Main Container - Full viewport */
        .hero-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .camera-scene {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
            cursor: grab;
        }

        .camera-scene.tooltip-active {
            cursor: default;
        }

        /* World map styling for camera system */
        .world-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            will-change: transform;
        }

        .world-image {
            display: block;
            max-width: none;
            max-height: none;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* Hotspots container - moves with the map */
        .hotspots-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%) scale(2);
            /* Match image scale */
            transform-origin: center center;
            pointer-events: none;
            z-index: 3;
        }

        /* Hotspot Styling */
        .hotspot {
            position: absolute;
            background: radial-gradient(circle, rgba(0, 150, 255, 0.8) 0%, rgba(0, 150, 255, 0.4) 70%, transparent 100%);
            border: 2px solid rgba(0, 150, 255, 0.6);
            cursor: pointer;
            pointer-events: auto;
            border-radius: 50%;
            width: 24px !important;
            height: 24px !important;
            padding: 4px;
            box-sizing: border-box;

            /* Interactive glow effect */
            box-shadow:
                0 0 12px rgba(0, 150, 255, 0.3),
                0 0 24px rgba(0, 150, 255, 0.1);

            /* Subtle pulse animation */
            animation: pulse-glow 2s ease-in-out infinite;
            /* Prevent any layout shifts */
            will-change: background;
            contain: layout style;
        }

        .hotspot:hover,
        .hotspot:focus {
            background: rgba(0, 150, 255, 0.15);
            outline: none;
            z-index: 5;
            /* Bring to front on hover */
        }

        /* Add a slightly larger hover detection area */
        .hotspot::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            pointer-events: auto;
            z-index: -1;
        }

        .hotspot::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: rgba(0, 150, 255, 0.9);
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
        }

        .hotspot:hover::after {
            animation: none;
            background: rgba(0, 150, 255, 1);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 8px rgba(0, 150, 255, 0.6);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 0.7;
            }
        }

        /* Debug mode styles */
        .debug-mode .hotspot {
            border: 2px solid red;
            background: rgba(255, 0, 0, 0.2);
        }

        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .debug-mode .debug-info {
            display: block;
        }

        .debug-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: red;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            display: none;
        }

        .debug-mode .debug-label {
            display: block;
        }

        /* Edge movement zones (debug mode only) */
        .edge-zone {
            position: fixed;
            background: rgba(255, 0, 0, 0.1);
            border: 1px dashed rgba(255, 0, 0, 0.3);
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        .debug-mode .edge-zone {
            display: block;
        }

        /* Hotspot Buttons */
        .hotspot {
            position: absolute;
            width: 28px;
            height: 28px;
            background: rgba(0, 123, 255, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 4px 12px rgba(0, 123, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }

        .hotspot:hover {
            transform: scale(1.3);
            background: rgba(0, 123, 255, 1);
            border-color: rgba(255, 255, 255, 1);
            box-shadow:
                0 6px 20px rgba(0, 123, 255, 0.5),
                0 4px 12px rgba(0, 0, 0, 0.3);
            animation: none;
        }

        .hotspot:active {
            transform: scale(1.1);
        }

        .hotspot::before {
            content: '';
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            opacity: 0.9;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow:
                    0 4px 12px rgba(0, 123, 255, 0.3),
                    0 2px 6px rgba(0, 0, 0, 0.2),
                    0 0 0 0 rgba(0, 123, 255, 0.4);
            }

            50% {
                box-shadow:
                    0 4px 12px rgba(0, 123, 255, 0.3),
                    0 2px 6px rgba(0, 0, 0, 0.2),
                    0 0 0 8px rgba(0, 123, 255, 0.1);
            }
        }

        .hotspots-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hotspots-overlay .hotspot {
            pointer-events: auto;
        }

        /* Tooltip Styles - Multi-Project Layout */
        .tooltip {
            position: fixed;
            background: #1A1818;
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 0;
            width: 480px;
            height: 400px;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.8) translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            pointer-events: none;
        }

        .tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        .tooltip-header {
            padding: 16px 16px 0 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tooltip-region-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 12px 0;
            line-height: 1.3;
        }

        .tooltip-content {
            max-height: 320px;
            overflow-y: auto;
            padding: 16px;
        }

        .tooltip-content::-webkit-scrollbar {
            width: 6px;
        }

        .tooltip-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .tooltip-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .tooltip-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .project-item {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .project-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .project-title {
            color: white;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.3;
            transition: opacity 0.2s ease;
        }

        .project-title:hover {
            opacity: 0.8;
        }

        .project-description {
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            margin: 0 0 12px 0;
            line-height: 1.5;
        }

        .project-links {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }

        .project-link {
            color: #007BFF;
            font-size: 13px;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .project-link:hover {
            color: #0056b3;
            text-decoration: underline;
        }

        .project-media {
            position: relative;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-bottom: 8px;
        }

        .project-media:last-of-type {
            margin-bottom: 0;
        }

        .project-media:hover {
            transform: scale(1.02);
        }

        .project-media img,
        .project-media video {
            width: 100%;
            height: auto;
            max-height: 200px;
            object-fit: contain;
            display: block;
            background: #000;
        }

        .project-media iframe {
            display: block;
            border: none;
        }

        /* Video Player Modal */
        .video-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .video-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .video-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-modal video {
            width: 100%;
            height: 100%;
            display: block;
        }

        .video-modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 3001;
            transition: background 0.2s ease;
        }

        .video-modal-close:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        /* Connection line animation */
        .connection-line {
            position: fixed;
            height: 2px;
            background: linear-gradient(90deg,
                    rgba(0, 123, 255, 0.8) 0%,
                    rgba(0, 123, 255, 0.6) 50%,
                    rgba(0, 123, 255, 0.4) 100%);
            transform-origin: 0 center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1999;
            pointer-events: none;
        }

        .connection-line.visible {
            opacity: 1;
            visibility: visible;
        }

        .connection-line::before {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: rgba(0, 123, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 12px rgba(0, 123, 255, 0.6);
        }

        /* Tooltip Arrow */
        .tooltip-arrow {
            display: none;
        }


        /* Pulse animation */
        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow:
                    0 0 12px rgba(0, 150, 255, 0.3),
                    0 0 24px rgba(0, 150, 255, 0.1);
            }

            50% {
                box-shadow:
                    0 0 16px rgba(0, 150, 255, 0.4),
                    0 0 32px rgba(0, 150, 255, 0.15);
            }
        }

        /* Hotspot hover effects */
        .hotspot {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hotspot:hover {
            transform: scale(1.15);
            background: radial-gradient(circle, rgba(0, 150, 255, 1) 0%, rgba(0, 150, 255, 0.6) 70%, transparent 100%);
            box-shadow:
                0 0 20px rgba(0, 150, 255, 0.6),
                0 0 40px rgba(0, 150, 255, 0.3),
                0 0 60px rgba(0, 150, 255, 0.1);
            border-color: rgba(0, 150, 255, 1);
            animation: none;
            /* Stop pulse on hover */
        }

        .hotspot:focus {
            outline: 2px solid rgba(0, 150, 255, 0.8);
            outline-offset: 4px;
        }

        .hotspot:active {
            transform: scale(1.05);
            transition-duration: 0.1s;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {

            .camera-scene,
            .world-layer,
            .world-image {
                transition: none !important;
                will-change: auto !important;
            }
        }


        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Mobile optimizations for tooltip */
        @media (max-width: 768px) {
            .tooltip {
                max-width: 260px;
            }

            .tooltip-title {
                font-size: 15px;
            }

            .tooltip-description {
                font-size: 12px;
            }
        }

        /* Mobile Tooltip Modal */
        @media (max-width: 1024px) {

            /* Hide desktop tooltip and connection line on mobile */
            .tooltip.visible {
                display: none;
            }

            .connection-line {
                display: none !important;
            }

            /* Mobile modal backdrop */
            .mobile-modal-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                z-index: 3000;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s ease, visibility 0.3s ease;
            }

            .mobile-modal-backdrop.visible {
                opacity: 1;
                visibility: visible;
            }

            /* Mobile modal container */
            .mobile-modal {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.9);
                width: 90vw;
                max-width: 500px;
                max-height: 85vh;
                background: #1A1818;
                border-radius: 16px;
                z-index: 3001;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .mobile-modal.visible {
                opacity: 1;
                visibility: visible;
                transform: translate(-50%, -50%) scale(1);
            }

            /* Modal header with close button */
            .mobile-modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                flex-shrink: 0;
            }

            .mobile-modal-title {
                font-size: 18px;
                font-weight: 600;
                color: white;
                margin: 0;
            }

            .mobile-modal-close {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.7);
                font-size: 28px;
                cursor: pointer;
                padding: 0;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: color 0.2s ease;
            }

            .mobile-modal-close:hover,
            .mobile-modal-close:active {
                color: white;
            }

            /* Modal content area (scrollable) */
            .mobile-modal-content {
                flex: 1;
                overflow-y: auto;
                padding: 20px;
                -webkit-overflow-scrolling: touch;
            }

            /* Larger hotspots for touch */
            .hotspot {
                width: 44px !important;
                height: 44px !important;
            }

            .hotspot::after {
                width: 20px;
                height: 20px;
            }
        }

        /* Zoom Debug Display */
        .zoom-debug {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 10000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none; /* Hidden */
        }

        .zoom-debug strong {
            color: #00ff00;
        }

        /* Import Modern Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Inter:wght@300;400;500;600&display=swap');

        /* Project Detail Modal - Tooltip Style */
        .project-detail-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 5000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .project-detail-backdrop.visible {
            opacity: 1;
            visibility: visible;
        }

        .project-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            background: #1A1818;
        }

        .project-detail-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .project-detail-close {
            position: fixed;
            top: 32px;
            right: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 5002;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 300;
        }

        .project-detail-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .project-nav-btn {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 5002;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .project-nav-prev {
            left: 32px;
        }

        .project-nav-next {
            right: 32px;
        }

        .project-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1.05);
        }

        .project-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .project-detail-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 100px 80px 80px;
            color: white;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        /* Header Section - Title and Metadata */
        .project-detail-header {
            margin-bottom: 60px;
            position: relative;
        }

        .project-detail-title {
            font-family: 'Syne', sans-serif;
            font-size: clamp(48px, 8vw, 80px);
            font-weight: 700;
            margin: 0 0 40px 0;
            line-height: 1.1;
            color: white;
            letter-spacing: -0.02em;
        }

        .project-detail-meta {
            display: flex;
            gap: 60px;
            padding: 0;
            border: none;
            margin-bottom: 0;
        }

        .meta-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            padding: 0;
        }

        .meta-item::before {
            display: none;
        }

        .meta-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            font-family: 'Inter', sans-serif;
        }

        .meta-value {
            font-size: 16px;
            color: white;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
        }

        /* Hero Media Section */
        .project-detail-hero {
            width: 100%;
            margin: 60px 0;
            position: relative;
        }

        .hero-media {
            width: 100%;
            min-height: 500px;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
        }

        .hero-media img,
        .hero-media video,
        .hero-media iframe {
            width: 100%;
            height: 100%;
            min-height: 500px;
            object-fit: cover;
            display: block;
        }

        /* Description Section */
        .project-detail-description-section {
            margin: 60px 0;
        }

        .description-title {
            font-family: 'Syne', sans-serif;
            font-size: 24px;
            font-weight: 600;
            margin: 0 0 20px 0;
            color: white;
        }

        .project-detail-description {
            font-size: 16px;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.85);
            margin: 0;
            max-width: none;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
        }

        /* Gallery Section - Grid Layout */
        .project-detail-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 24px;
            margin-top: 60px;
        }

        .gallery-item {
            position: relative;
            aspect-ratio: 16/9;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .gallery-item:hover {
            transform: translateY(-4px);
            opacity: 0.9;
        }

        .gallery-item img,
        .gallery-item video,
        .gallery-item iframe {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Lightbox - Clean Style */
        .lightbox-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 6000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .lightbox-backdrop.visible {
            opacity: 1;
            visibility: visible;
        }

        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 6001;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .lightbox.visible {
            opacity: 1;
            visibility: visible;
        }

        .lightbox-close {
            position: fixed;
            top: 32px;
            right: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 6002;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .lightbox-nav {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 6002;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-nav-prev {
            left: 32px;
        }

        .lightbox-nav-next {
            right: 32px;
        }

        .lightbox-nav:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1.05);
        }

        .lightbox-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .lightbox-content {
            max-width: 90%;
            max-height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-content img,
        .lightbox-content video {
            max-width: 100%;
            max-height: 85vh;
            object-fit: contain;
        }

        /* Mobile Responsiveness for Project Detail */
        @media (max-width: 1024px) {
            .project-detail-content {
                padding: 80px 40px 60px;
            }

            .project-detail-title {
                font-size: clamp(40px, 10vw, 64px);
                margin-bottom: 32px;
            }

            .project-detail-meta {
                flex-direction: column;
                gap: 20px;
            }

            .hero-media {
                min-height: 350px;
            }

            .hero-media img,
            .hero-media video,
            .hero-media iframe {
                min-height: 350px;
            }

            .description-title {
                font-size: 20px;
            }

            .project-detail-description {
                font-size: 15px;
            }

            .project-detail-gallery {
                grid-template-columns: 1fr;
                gap: 16px;
                margin-top: 48px;
            }

            .project-nav-btn,
            .project-detail-close {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }

            .project-nav-prev {
                left: 20px;
            }

            .project-nav-next {
                right: 20px;
            }

            .project-detail-close {
                top: 20px;
                right: 20px;
            }

            .lightbox {
                padding: 80px 20px 20px;
            }

            .lightbox-nav {
                width: 48px;
                height: 48px;
            }
        }

        @media (max-width: 640px) {
            .project-detail-content {
                padding: 60px 24px 40px;
            }

            .project-detail-title {
                font-size: clamp(32px, 12vw, 48px);
                margin-bottom: 24px;
            }

            .project-detail-meta {
                gap: 16px;
            }

            .meta-value {
                font-size: 14px;
            }

            .hero-media {
                min-height: 250px;
                border-radius: 8px;
            }

            .hero-media img,
            .hero-media video,
            .hero-media iframe {
                min-height: 250px;
            }

            .description-title {
                font-size: 18px;
            }

            .project-detail-description {
                font-size: 14px;
            }

            .project-detail-gallery {
                margin-top: 32px;
            }

            .gallery-item {
                border-radius: 8px;
            }

            .project-nav-btn {
                width: 40px;
                height: 40px;
            }

            .project-nav-prev {
                left: 16px;
            }

            .project-nav-next {
                right: 16px;
            }

            .project-detail-close {
                top: 16px;
                right: 16px;
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p>Loading Portfolio...</p>
        </div>
    </div>

    <!-- Zoom Debug Display -->
    <div class="zoom-debug" id="zoomDebug">
        Zoom: <strong id="zoomValue">0.00</strong>
    </div>

    <div class="hero-container">
        <div class="camera-scene" id="cameraScene">
            <!-- World Map Layer -->
            <div class="world-layer" id="worldLayer">
                <img src="assets/images/TM-world.png" alt="World Map" class="world-image" id="worldImage"
                    onerror="console.error('Core Map Image failed to load from assets/images/TM-world.png')">

                <!-- Hotspots Overlay -->
                <div class="hotspots-overlay" id="hotspotsOverlay">
                    <!-- Hotspots will be dynamically inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Info Panel -->
    <div class="debug-info" id="debugInfo">
        <div>Container: <span id="debugContainer">0x0</span></div>
        <div>Image Rect: <span id="debugImageRect">0x0+0+0</span></div>
        <div>Position: <span id="debugPosition">0.00, 0.00</span></div>
        <div>Smooth: <span id="debugSmooth">0.00, 0.00</span></div>
        <div>Mouse: <span id="debugMouse">0, 0</span></div>
        <div>Edge Move: <span id="debugEdge">none</span></div>
        <div>Press 'D' to toggle debug mode</div>
    </div>

    <!-- Edge movement zones (debug mode only) -->
    <div class="edge-zone" id="edgeTop"></div>
    <div class="edge-zone" id="edgeRight"></div>
    <div class="edge-zone" id="edgeBottom"></div>
    <div class="edge-zone" id="edgeLeft"></div>

    <!-- Tooltip -->
    <div class="tooltip" id="projectTooltip">
        <div class="tooltip-header">
            <h2 class="tooltip-region-title" id="tooltipRegionTitle">Region Name</h2>
        </div>
        <div class="tooltip-content" id="tooltipContent">
            <!-- Projects will be dynamically inserted -->
        </div>
    </div>

    <!-- Mobile Modal (hidden by default, shown on mobile) -->
    <div id="mobileModalBackdrop" class="mobile-modal-backdrop"></div>
    <div id="mobileModal" class="mobile-modal">
        <div class="mobile-modal-header">
            <h2 id="mobileModalTitle" class="mobile-modal-title"></h2>
            <button id="mobileModalClose" class="mobile-modal-close" aria-label="Close">&times;</button>
        </div>
        <div id="mobileModalContent" class="mobile-modal-content"></div>
    </div>

    <!-- Video Player Modal -->
    <div class="video-modal" id="videoModal">
        <div class="video-modal-content">
            <button class="video-modal-close" id="videoModalClose">&times;</button>
            <video id="modalVideo" controls>
                <source id="modalVideoSource" src="" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        </div>
    </div>

    <!-- Project Detail Modal -->
    <div id="projectDetailBackdrop" class="project-detail-backdrop"></div>
    <div id="projectDetailModal" class="project-detail-modal">
        <button id="projectDetailClose" class="project-detail-close" aria-label="Close">&times;</button>

        <!-- Navigation Buttons -->
        <button id="projectPrevBtn" class="project-nav-btn project-nav-prev" aria-label="Previous Project">
            <svg viewBox="0 0 24 24" width="24" height="24">
                <path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
            </svg>
        </button>
        <button id="projectNextBtn" class="project-nav-btn project-nav-next" aria-label="Next Project">
            <svg viewBox="0 0 24 24" width="24" height="24">
                <path fill="currentColor" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
            </svg>
        </button>

        <div class="project-detail-content">
            <!-- Project Header -->
            <div class="project-detail-header">
                <h1 id="projectDetailTitle" class="project-detail-title"></h1>
                <div class="project-detail-meta">
                    <div class="meta-item">
                        <span class="meta-label">Client</span>
                        <span id="projectDetailClient" class="meta-value"></span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Service</span>
                        <span id="projectDetailService" class="meta-value"></span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Date</span>
                        <span id="projectDetailDate" class="meta-value"></span>
                    </div>
                </div>
            </div>

            <!-- Hero Media -->
            <div id="projectDetailHero" class="project-detail-hero"></div>

            <!-- Description Section -->
            <div id="projectDetailDescriptionSection" class="project-detail-description-section">
                <h2 class="description-title">Description</h2>
                <p id="projectDetailDescription" class="project-detail-description"></p>
            </div>

            <!-- Media Gallery -->
            <div id="projectDetailGallery" class="project-detail-gallery"></div>
        </div>
    </div>

    <!-- Lightbox for Full-Screen Media -->
    <div id="lightboxBackdrop" class="lightbox-backdrop"></div>
    <div id="lightbox" class="lightbox">
        <button id="lightboxClose" class="lightbox-close" aria-label="Close">&times;</button>
        <button id="lightboxPrev" class="lightbox-nav lightbox-nav-prev" aria-label="Previous">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
            </svg>
        </button>
        <button id="lightboxNext" class="lightbox-nav lightbox-nav-next" aria-label="Next">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path fill="currentColor" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
            </svg>
        </button>
        <div id="lightboxContent" class="lightbox-content"></div>
    </div>

    <!-- Connection Line -->
    <div class="connection-line" id="connectionLine"></div>

    <script>
        // Project data will be loaded dynamically from API
        let projectsData = [];

        /*
        Example data structure for multiple projects per region:
        
        projectsData = [
            // Old format - single project (still supported)
            {
                id: 1,
                title: "Single Project",
                description: "A standalone project",
                image_url: "/uploads/image1.jpg",
                video_url: "/uploads/video1.mp4",
                links: [{ text: "GitHub", url: "https://github.com/..." }],
                coordinates: { x: 0.3, y: 0.4, w: 0.1, h: 0.1 }
            },
            
            // New format - region with multiple projects
            {
                id: 2,
                name: "Southeast Asia Region",  // Region name instead of title
                projects: [  // Array of projects in this region
                    {
                        title: "Bangkok Traffic Analysis",
                        description: "Real-time traffic data visualization",
                        image_url: "/uploads/bangkok.jpg",
                        links: [{ text: "Live Demo", url: "https://..." }]
                    },
                    {
                        title: "Singapore IoT Network",
                        description: "Smart city sensor network",
                        video_url: "/uploads/singapore.mp4",
                        links: [{ text: "Documentation", url: "https://..." }]
                    },
                    {
                        title: "Jakarta Flood Monitoring",
                        description: "Early warning system for floods",
                        image_url: "/uploads/jakarta.jpg",
                        links: [{ text: "Report", url: "https://..." }]
                    }
                ],
                coordinates: { x: 0.7, y: 0.6, w: 0.1, h: 0.1 }
            }
        ];
        */

        class CameraController {
            constructor() {
                this.scene = document.getElementById('cameraScene');
                this.worldLayer = document.getElementById('worldLayer');
                this.worldImage = document.getElementById('worldImage');
                this.hotspotsOverlay = document.getElementById('hotspotsOverlay');

                // Detect mobile/tablet devices
                this.isMobile = this.detectMobile();

                // Camera System Constants for TM-world.png
                this.motionConfig = {
                    zoomScale: this.isMobile ? 0.25 : 0.5,      // 25% mobile, 50% desktop
                    maxCameraX: 0,       // Will be calculated based on image size
                    maxCameraY: 0,       // Will be calculated based on image size
                    lerpFactor: 0.08,    // Smooth camera movement
                    dragSensitivity: 1.0,

                    // Edge movement settings
                    edgeZone: this.isMobile ? 30 : 50,        // Smaller zones on mobile
                    edgeSpeed: this.isMobile ? 2.0 : 3.0      // Slower speed on mobile
                };

                // Camera position state
                this.camera = {
                    x: 0,        // Current camera position
                    y: 0,
                    targetX: 0,  // Target camera position
                    targetY: 0
                };

                // Drag state
                this.dragState = {
                    isActive: false,
                    startX: 0,
                    startY: 0,
                    startCameraX: 0,
                    startCameraY: 0
                };

                // Pinch-to-zoom state (mobile only)
                this.pinchState = {
                    isActive: false,
                    startDistance: 0,
                    startZoom: 0
                };

                // Current zoom level (dynamic on mobile, fixed on desktop)
                this.currentZoom = this.motionConfig.zoomScale;
                this.minZoom = 0.25;  // Maximum zoom out (shows full map)
                this.maxZoom = 1.0;   // Maximum zoom in (adjust based on image quality)

                // Image dimensions
                this.imageRect = { width: 0, height: 0 };
                this.debugMode = false;
                this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                // Edge movement state
                this.edgeMovement = {
                    active: false,
                    mouseX: 0,
                    mouseY: 0
                };

                this.init();
            }

            async init() {
                try {
                    // Load projects from API
                    await this.loadProjects();

                    this.setupEventListeners();
                    this.createHotspots();
                    this.startAnimation();

                    // Wait for image to load and initialize camera system
                    this.waitForImageLoad(this.worldImage).then(() => {
                        const finalize = () => {
                            if (this.scene.clientWidth > 0 && this.worldImage.naturalWidth > 0) {
                                this.calculateCameraBounds();
                                this.updateHotspots();

                                // Start camera at center with 12.5% zoom
                                this.camera.x = this.camera.targetX = 0;
                                this.camera.y = this.camera.targetY = 0;

                                this.applyTransforms();
                                this.hideLoading();
                            } else {
                                requestAnimationFrame(finalize);
                            }
                        };
                        finalize();
                    });
                } catch (error) {
                    console.error('Failed to initialize portfolio:', error);
                    projectsData = [];
                    this.setupEventListeners();
                    this.startAnimation();
                    this.hideLoading();
                }
            }

            hideLoading() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.add('hidden');
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }
            }

            async loadProjects() {
                try {
                    const response = await fetch('/api/projects');
                    const data = await response.json();

                    if (data.success && Array.isArray(data.data)) {
                        projectsData = data.data.map(item => {
                            if (item.projects && Array.isArray(item.projects)) {
                                // This is a tooltip with multiple projects
                                return {
                                    id: item.id.toString(),
                                    name: item.name, // Tooltip name
                                    projects: item.projects, // Array of projects
                                    region: item.coordinates || { x: 0.5, y: 0.5, w: 0.1, h: 0.1 }
                                };
                            } else {
                                // This is a legacy single project
                                return {
                                    id: item.id.toString(),
                                    title: item.title,
                                    description: item.description || '',
                                    links: item.links || [],
                                    region: item.coordinates || { x: 0.5, y: 0.5, w: 0.1, h: 0.1 },
                                    image_url: item.image_url,
                                    video_url: item.video_url
                                };
                            }
                        });
                    } else {
                        projectsData = [];
                    }
                } catch (error) {
                    console.error('Failed to load projects:', error);
                    try {
                        const fallbackResponse = await fetch('/data/projects.json');
                        projectsData = await fallbackResponse.json();
                    } catch (fallbackError) {
                        projectsData = [];
                    }
                }
            }

            waitForImageLoad(img) {
                return new Promise((resolve) => {
                    if (img.complete) {
                        resolve();
                    } else {
                        img.addEventListener('load', () => {
                            console.log('Map image loaded successfully:', img.src);
                            resolve();
                        });
                        img.addEventListener('error', (e) => {
                            console.error('Map image FAILED to load:', img.src, e);
                            resolve(); // Proceed anyway to avoid hanging
                        });
                    }
                });
            }

            setupEventListeners() {
                // Mouse Drag Events
                this.scene.addEventListener('mousedown', this.handleDragStart.bind(this));
                window.addEventListener('mousemove', this.handleDragMove.bind(this));
                window.addEventListener('mouseup', this.handleDragEnd.bind(this));

                // Touch Drag Events
                this.scene.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.scene.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.scene.addEventListener('touchend', this.handleDragEnd.bind(this));

                // Global resize
                window.addEventListener('resize', this.handleResize.bind(this));

                // Debug/UI shortcuts
                document.addEventListener('keydown', this.handleKeyDown.bind(this));

                // Edge movement - track mouse position globally
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseenter', () => this.edgeMovement.active = true);
                document.addEventListener('mouseleave', () => this.edgeMovement.active = false);

                this.setupTooltipEvents();
            }

            // Unified Drag Handler
            handleDragStart(e) {
                if (e.button !== 0) return; // Only left click

                // Check if tooltip is visible - if so, don't allow dragging
                const tooltip = document.getElementById('projectTooltip');
                if (tooltip && tooltip.classList.contains('visible')) {
                    return;
                }
                e.preventDefault(); // Prevent native browser drag
                this.initDrag(e.clientX, e.clientY);
            }

            handleTouchStart(e) {
                // Check if tooltip/modal is visible
                const tooltip = document.getElementById('projectTooltip');
                const modal = document.getElementById('mobileModal');
                if ((tooltip && tooltip.classList.contains('visible')) ||
                    (modal && modal.classList.contains('visible'))) {
                    return;
                }

                if (e.touches.length === 2 && this.isMobile) {
                    // Two-finger pinch to zoom (mobile only)
                    e.preventDefault();
                    const distance = this.getTouchDistance(e.touches[0], e.touches[1]);
                    this.pinchState.isActive = true;
                    this.pinchState.startDistance = distance;
                    this.pinchState.startZoom = this.currentZoom;
                    this.dragState.isActive = false; // Cancel drag if active
                } else if (e.touches.length === 1) {
                    // Single-finger drag
                    const touch = e.touches[0];
                    this.initDrag(touch.clientX, touch.clientY);
                }
            }

            initDrag(x, y) {
                this.dragState.isActive = true;
                this.dragState.startX = x;
                this.dragState.startY = y;
                this.dragState.startCameraX = this.camera.targetX;
                this.dragState.startCameraY = this.camera.targetY;
                this.scene.style.cursor = 'grabbing';
            }

            handleDragMove(e) {
                if (!this.dragState.isActive) return;
                this.updateDrag(e.clientX, e.clientY);
            }

            handleTouchMove(e) {
                if (e.touches.length === 2 && this.pinchState.isActive && this.isMobile) {
                    // Handle pinch zoom
                    e.preventDefault();
                    const currentDistance = this.getTouchDistance(e.touches[0], e.touches[1]);
                    const scale = currentDistance / this.pinchState.startDistance;

                    // Calculate new zoom level
                    let newZoom = this.pinchState.startZoom * scale;

                    // Clamp zoom to min/max limits
                    newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));

                    // Apply zoom
                    this.currentZoom = newZoom;
                    this.calculateCameraBounds();
                    this.applyTransforms();
                } else if (e.touches.length === 1 && this.dragState.isActive) {
                    // Handle drag
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.updateDrag(touch.clientX, touch.clientY);
                }
            }

            updateDrag(x, y) {
                const dx = x - this.dragState.startX;
                const dy = y - this.dragState.startY;

                // Update target camera position (1:1 with screen pixels)
                let newTargetX = this.dragState.startCameraX - dx;
                let newTargetY = this.dragState.startCameraY - dy;

                // Clamp to boundaries to prevent showing empty edges
                this.camera.targetX = Math.max(-this.motionConfig.maxCameraX, Math.min(this.motionConfig.maxCameraX, newTargetX));
                this.camera.targetY = Math.max(-this.motionConfig.maxCameraY, Math.min(this.motionConfig.maxCameraY, newTargetY));
            }

            handleDragEnd() {
                this.dragState.isActive = false;
                this.pinchState.isActive = false;
                this.scene.style.cursor = 'grab';
            }

            handleResize() {
                // Update mobile detection
                const wasMobile = this.isMobile;
                this.isMobile = this.detectMobile();

                // Update zoom scale and edge settings if device type changed
                if (wasMobile !== this.isMobile) {
                    this.motionConfig.zoomScale = this.isMobile ? 0.25 : 0.5;
                    this.currentZoom = this.motionConfig.zoomScale;  // Reset zoom on device change
                    this.motionConfig.edgeZone = this.isMobile ? 30 : 50;
                    this.motionConfig.edgeSpeed = this.isMobile ? 2.0 : 3.0;
                }

                this.updateImageRect();
                this.updateHotspots();

                if (this.debugMode) {
                    this.setupDebugEdgeZones();
                }
            }

            getTouchDistance(touch1, touch2) {
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            handleMouseMove(e) {
                // Update mouse position for edge movement
                this.edgeMovement.mouseX = e.clientX;
                this.edgeMovement.mouseY = e.clientY;
            }

            handleKeyDown(e) {
                if (e.key.toLowerCase() === 'd') {
                    this.toggleDebugMode();
                }
                if (e.key === 'Escape') {
                    this.hideTooltip();
                }
            }

            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                document.body.classList.toggle('debug-mode', this.debugMode);

                if (this.debugMode) {
                    this.setupDebugEdgeZones();
                }
            }

            setupDebugEdgeZones() {
                const edgeZone = this.motionConfig.edgeZone;
                const vw = window.innerWidth;
                const vh = window.innerHeight;

                // Top edge zone
                const edgeTop = document.getElementById('edgeTop');
                edgeTop.style.left = '0';
                edgeTop.style.top = '0';
                edgeTop.style.width = '100%';
                edgeTop.style.height = `${edgeZone}px`;

                // Right edge zone
                const edgeRight = document.getElementById('edgeRight');
                edgeRight.style.right = '0';
                edgeRight.style.top = '0';
                edgeRight.style.width = `${edgeZone}px`;
                edgeRight.style.height = '100%';

                // Bottom edge zone
                const edgeBottom = document.getElementById('edgeBottom');
                edgeBottom.style.left = '0';
                edgeBottom.style.bottom = '0';
                edgeBottom.style.width = '100%';
                edgeBottom.style.height = `${edgeZone}px`;

                // Left edge zone
                const edgeLeft = document.getElementById('edgeLeft');
                edgeLeft.style.left = '0';
                edgeLeft.style.top = '0';
                edgeLeft.style.width = `${edgeZone}px`;
                edgeLeft.style.height = '100%';
            }

            startAnimation() {
                const animate = () => {
                    this.updateSmoothing();
                    this.applyTransforms();
                    this.updateDebugInfo();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            updateSmoothing() {
                // Check if tooltip is visible - if so, disable all movement
                const tooltip = document.getElementById('projectTooltip');
                const tooltipVisible = tooltip && tooltip.classList.contains('visible');

                // Update edge movement if active, not dragging, and tooltip not visible
                if (this.edgeMovement.active && !this.dragState.isActive && !tooltipVisible) {
                    this.updateEdgeMovement();
                }

                if (this.prefersReducedMotion) {
                    this.camera.x = this.camera.targetX;
                    this.camera.y = this.camera.targetY;
                    return;
                }

                // Smooth camera movement interpolation
                const lerpFactor = this.motionConfig.lerpFactor;
                this.camera.x += (this.camera.targetX - this.camera.x) * lerpFactor;
                this.camera.y += (this.camera.targetY - this.camera.y) * lerpFactor;
            }

            updateEdgeMovement() {
                const { mouseX, mouseY } = this.edgeMovement;
                const { edgeZone, edgeSpeed, maxCameraX, maxCameraY } = this.motionConfig;
                const viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };

                let moveX = 0;
                let moveY = 0;

                // Check horizontal edges
                if (mouseX < edgeZone) {
                    // Left edge - move camera left (negative direction)
                    const intensity = (edgeZone - mouseX) / edgeZone;
                    moveX = -edgeSpeed * intensity;
                } else if (mouseX > viewport.width - edgeZone) {
                    // Right edge - move camera right (positive direction)
                    const intensity = (mouseX - (viewport.width - edgeZone)) / edgeZone;
                    moveX = edgeSpeed * intensity;
                }

                // Check vertical edges
                if (mouseY < edgeZone) {
                    // Top edge - move camera up (negative direction)
                    const intensity = (edgeZone - mouseY) / edgeZone;
                    moveY = -edgeSpeed * intensity;
                } else if (mouseY > viewport.height - edgeZone) {
                    // Bottom edge - move camera down (positive direction)
                    const intensity = (mouseY - (viewport.height - edgeZone)) / edgeZone;
                    moveY = edgeSpeed * intensity;
                }

                // Apply edge movement to camera target
                if (moveX !== 0 || moveY !== 0) {
                    let newTargetX = this.camera.targetX + moveX;
                    let newTargetY = this.camera.targetY + moveY;

                    // Clamp to boundaries
                    this.camera.targetX = Math.max(-maxCameraX, Math.min(maxCameraX, newTargetX));
                    this.camera.targetY = Math.max(-maxCameraY, Math.min(maxCameraY, newTargetY));
                }
            }

            applyTransforms() {
                const moveX = -this.camera.x;
                const moveY = -this.camera.y;
                const scale = this.currentZoom;  // Use dynamic zoom level

                // Apply camera movement to both image and hotspots
                const transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px) scale(${scale})`;

                this.worldImage.style.transform = transform;
                this.hotspotsOverlay.style.transform = transform;

                // Update zoom debug display
                this.updateZoomDebug();
            }

            detectMobile() {
                // Detect mobile/tablet devices (up to 1024px width)
                return window.innerWidth <= 1024 ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            updateZoomDebug() {
                const zoomDebug = document.getElementById('zoomValue');
                if (zoomDebug) {
                    zoomDebug.textContent = this.currentZoom.toFixed(2);
                }
            }

            calculateCameraBounds() {
                const cw = this.scene.clientWidth;
                const ch = this.scene.clientHeight;
                const iw = this.worldImage.naturalWidth;
                const ih = this.worldImage.naturalHeight;

                if (!iw || !ih || !cw || !ch) return;

                // Calculate how much we can move the camera at current zoom level
                const scaledImageWidth = iw * this.currentZoom;
                const scaledImageHeight = ih * this.currentZoom;

                // Maximum camera movement is half the difference between scaled image and viewport
                this.motionConfig.maxCameraX = Math.max(0, (scaledImageWidth - cw) / 2);
                this.motionConfig.maxCameraY = Math.max(0, (scaledImageHeight - ch) / 2);

                this.imageRect = {
                    width: scaledImageWidth,
                    height: scaledImageHeight
                };

                console.log('Camera bounds calculated:', {
                    viewport: `${cw}x${ch}`,
                    image: `${iw}x${ih}`,
                    scaled: `${scaledImageWidth}x${scaledImageHeight}`,
                    maxMovement: `${this.motionConfig.maxCameraX}x${this.motionConfig.maxCameraY}`
                });
            }

            updateImageRect() {
                this.calculateCameraBounds();

                // Clamp current camera to new boundaries
                this.camera.targetX = Math.max(-this.motionConfig.maxCameraX, Math.min(this.motionConfig.maxCameraX, this.camera.targetX));
                this.camera.targetY = Math.max(-this.motionConfig.maxCameraY, Math.min(this.motionConfig.maxCameraY, this.camera.targetY));
            }

            createHotspots() {
                projectsData.forEach(project => {
                    const hotspot = document.createElement('button');
                    hotspot.className = 'hotspot';
                    hotspot.setAttribute('data-project-id', project.id);
                    hotspot.setAttribute('aria-label', `Open ${project.title} project details`);

                    // Add debug label
                    const label = document.createElement('div');
                    label.className = 'debug-label';
                    label.textContent = project.id;
                    hotspot.appendChild(label);

                    // Click handler
                    hotspot.addEventListener('click', () => this.showTooltip(project, hotspot));

                    // Hover handlers for interaction feedback
                    hotspot.addEventListener('mouseenter', () => this.disableMovement(), true);
                    hotspot.addEventListener('mouseleave', () => this.enableMovement(), true);

                    // Also add pointer events for more reliable detection
                    hotspot.addEventListener('pointerenter', () => this.disableMovement());
                    hotspot.addEventListener('pointerleave', () => this.enableMovement());

                    this.hotspotsOverlay.appendChild(hotspot);
                });

                this.updateHotspots();
            }

            updateHotspots() {
                const hotspots = this.hotspotsOverlay.querySelectorAll('.hotspot');

                hotspots.forEach((hotspot, index) => {
                    const project = projectsData[index];
                    if (!project) return;

                    const { x, y } = project.region;
                    const iw = this.worldImage.naturalWidth || 1000;
                    const ih = this.worldImage.naturalHeight || 1000;

                    // Position hotspots relative to the image
                    // Since the overlay is scaled the same as the image, we can use natural image coordinates
                    const posX = (x - 0.5) * iw; // Convert from 0-1 to pixels from center
                    const posY = (y - 0.5) * ih;

                    hotspot.style.left = `calc(50% + ${posX}px)`;
                    hotspot.style.top = `calc(50% + ${posY}px)`;
                    hotspot.style.transform = `translate(-50%, -50%)`;
                });
            }

            // Tooltip functionality
            setupTooltipEvents() {
                const tooltip = document.getElementById('projectTooltip');
                const videoModal = document.getElementById('videoModal');
                const videoModalClose = document.getElementById('videoModalClose');

                // Close tooltip when clicking outside
                document.addEventListener('click', (e) => {
                    if (!tooltip.contains(e.target) && !e.target.closest('.hotspot')) {
                        this.hideTooltip();
                    }
                });

                // Disable movement when hovering tooltip
                tooltip.addEventListener('mouseenter', () => this.disableMovement());
                tooltip.addEventListener('mouseleave', () => this.enableMovement());

                // Video modal event handlers
                videoModalClose.addEventListener('click', () => {
                    this.closeVideoModal();
                });

                // Close video modal when clicking outside
                videoModal.addEventListener('click', (e) => {
                    if (e.target === videoModal) {
                        this.closeVideoModal();
                    }
                });

                // Close video modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && videoModal.classList.contains('visible')) {
                        this.closeVideoModal();
                    }
                });
            }

            showTooltip(project, hotspot) {
                // Handle both old format (single projects) and new format (tooltips with multiple projects)
                if (project.projects && Array.isArray(project.projects)) {
                    // New format: this is a tooltip with multiple projects
                    const tooltip = {
                        name: project.name || "Tooltip", // Use the tooltip name
                        projects: project.projects
                    };
                    this.showRegionTooltip(tooltip, hotspot);
                } else {
                    // Old format: treat single project as a tooltip with one project
                    const tooltip = {
                        name: (project.title || "Project") + " Area", // Fallback for legacy projects
                        projects: [project] // Convert single project to array
                    };
                    this.showRegionTooltip(tooltip, hotspot);
                }
            }

            showRegionTooltip(tooltipData, hotspot) {
                // Check if mobile - show modal instead of tooltip
                if (this.isMobile) {
                    this.showMobileModal(tooltipData);
                    return;
                }

                const tooltip = document.getElementById('projectTooltip');
                const connectionLine = document.getElementById('connectionLine');
                const tooltipTitle = document.getElementById('tooltipRegionTitle');
                const content = document.getElementById('tooltipContent');

                // Hide connection line first
                connectionLine.classList.remove('visible');
                connectionLine.style.cssText = '';

                // Set tooltip title
                tooltipTitle.textContent = tooltipData.name || "Tooltip";

                // Clear and populate projects
                content.innerHTML = '';

                // Ensure projects array exists
                if (!tooltipData.projects || !Array.isArray(tooltipData.projects)) {
                    console.warn('Invalid tooltip data: projects array missing or invalid', tooltipData);
                    tooltipData.projects = [];
                }

                tooltipData.projects.forEach((project, projectIndex) => {
                    const projectItem = document.createElement('div');
                    projectItem.className = 'project-item';

                    const hasLink = project.links && project.links.length > 0;

                    // Create project title
                    const title = document.createElement('h3');
                    title.className = 'project-title';

                    // Add partner label based on 'under' field
                    let titleText = project.title || 'Untitled Project';
                    const under = project.under || 'Turfmapp';

                    if (under !== 'Turfmapp') {
                        titleText += ` - Partnered with ${under}`;
                    }

                    title.textContent = titleText;

                    // Make title clickable - opens project detail modal
                    title.style.cursor = 'pointer';
                    title.style.textDecoration = 'underline';
                    title.addEventListener('click', () => {
                        // Close tooltip first
                        this.hideTooltip();
                        // Open project detail modal
                        this.openProjectDetail(project, tooltipData.projects, projectIndex);
                    });

                    projectItem.appendChild(title);

                    // Add project description right after title
                    if (project.description) {
                        const description = document.createElement('p');
                        description.className = 'project-description';
                        description.textContent = project.description;
                        projectItem.appendChild(description);
                    }

                    // Display YouTube video if available (highest priority)
                    if (project.youtube_url) {
                        const mediaContainer = document.createElement('div');
                        mediaContainer.className = 'project-media';

                        const youtubeId = this.getYouTubeVideoId(project.youtube_url);
                        if (youtubeId) {
                            const iframe = document.createElement('iframe');
                            iframe.src = `https://www.youtube.com/embed/${youtubeId}`;
                            iframe.setAttribute('frameborder', '0');
                            iframe.setAttribute('allowfullscreen', '');
                            iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                            iframe.style.width = '100%';
                            iframe.style.height = '200px';
                            iframe.style.borderRadius = '8px';
                            mediaContainer.appendChild(iframe);

                            if (hasLink) {
                                mediaContainer.style.cursor = 'pointer';
                                mediaContainer.addEventListener('click', (e) => {
                                    if (e.target === mediaContainer) {
                                        window.open(project.links[0].url, '_blank', 'noopener,noreferrer');
                                    }
                                });
                            }

                            projectItem.appendChild(mediaContainer);
                        }
                    }

                    // Display all media from media array (new format)
                    if (project.media && Array.isArray(project.media) && project.media.length > 0) {
                        project.media.forEach(mediaItem => {
                            const mediaContainer = document.createElement('div');
                            mediaContainer.className = 'project-media';

                            if (mediaItem.type === 'video') {
                                const video = document.createElement('video');
                                video.src = mediaItem.url;
                                video.muted = true;
                                video.preload = 'metadata';
                                mediaContainer.appendChild(video);

                                mediaContainer.addEventListener('click', () => {
                                    // Close tooltip/modal and open project detail modal
                                    this.hideTooltip();
                                    this.openProjectDetail(project, tooltipData.projects, projectIndex);
                                });
                            } else {
                                const img = document.createElement('img');
                                img.src = mediaItem.url;
                                img.alt = project.title;
                                mediaContainer.appendChild(img);

                                mediaContainer.addEventListener('click', () => {
                                    // Close tooltip/modal and open project detail modal
                                    this.hideTooltip();
                                    this.openProjectDetail(project, tooltipData.projects, projectIndex);
                                });
                            }

                            projectItem.appendChild(mediaContainer);
                        });
                    } else if (project.image_url || project.video_url) {
                        // Fallback: Display single media (old format for backward compatibility)
                        const mediaContainer = document.createElement('div');
                        mediaContainer.className = 'project-media';

                        const mediaUrl = project.video_url || project.image_url;
                        const isVideo = !!project.video_url;

                        if (isVideo) {
                            const video = document.createElement('video');
                            video.src = mediaUrl;
                            video.muted = true;
                            video.preload = 'metadata';
                            mediaContainer.appendChild(video);

                            mediaContainer.addEventListener('click', () => {
                                // Close tooltip/modal and open project detail modal
                                this.hideTooltip();
                                this.openProjectDetail(project, tooltipData.projects, projectIndex);
                            });
                        } else {
                            const img = document.createElement('img');
                            img.src = mediaUrl;
                            img.alt = project.title;
                            mediaContainer.appendChild(img);

                            mediaContainer.addEventListener('click', () => {
                                // Close tooltip/modal and open project detail modal
                                this.hideTooltip();
                                this.openProjectDetail(project, tooltipData.projects, projectIndex);
                            });
                        }

                        projectItem.appendChild(mediaContainer);
                    }

                    // Add project links as text ONLY if there's no media
                    // (If media exists, links are embedded in the media)
                    const hasMedia = project.youtube_url || (project.media && project.media.length > 0) || project.image_url || project.video_url;
                    if (!hasMedia && project.links && project.links.length > 0) {
                        const linksContainer = document.createElement('div');
                        linksContainer.className = 'project-links';

                        project.links.forEach(link => {
                            const linkEl = document.createElement('a');
                            linkEl.href = link.url;
                            linkEl.textContent = link.text;
                            linkEl.className = 'project-link';
                            linkEl.target = '_blank';
                            linkEl.rel = 'noopener noreferrer';
                            linksContainer.appendChild(linkEl);
                        });

                        projectItem.appendChild(linksContainer);
                    }

                    content.appendChild(projectItem);
                });

                // Remove visible class but keep tooltip in DOM for positioning
                tooltip.classList.remove('visible');
                tooltip.className = 'tooltip'; // Reset position classes

                // Position tooltip near hotspot (this sets the position class)
                this.positionTooltip(tooltip, hotspot);

                // Disable movement when tooltip is shown
                this.disableMovement();
                this.scene.classList.add('tooltip-active');

                // Show tooltip immediately after positioning
                tooltip.classList.add('visible');

                // Create connection line with sufficient delay for positioning to complete
                setTimeout(() => {
                    this.showConnectionLine(hotspot, tooltip);
                }, 200);
            }

            showMobileModal(tooltipData) {
                const backdrop = document.getElementById('mobileModalBackdrop');
                const modal = document.getElementById('mobileModal');
                const modalTitle = document.getElementById('mobileModalTitle');
                const modalContent = document.getElementById('mobileModalContent');
                const closeBtn = document.getElementById('mobileModalClose');

                // Set title
                modalTitle.textContent = tooltipData.name || "Project";

                // Clear and populate content (reuse existing project rendering logic)
                modalContent.innerHTML = '';

                if (!tooltipData.projects || !Array.isArray(tooltipData.projects)) {
                    tooltipData.projects = [];
                }

                // Close modal helper
                const closeMobileModal = () => {
                    backdrop.classList.remove('visible');
                    modal.classList.remove('visible');
                    this.enableMovement();
                    document.body.style.overflow = '';
                };

                // Render projects (same logic as desktop tooltip)
                tooltipData.projects.forEach((project, projectIndex) => {
                    const projectItem = document.createElement('div');
                    projectItem.className = 'project-item';

                    const hasLink = project.links && project.links.length > 0;

                    // Create project title
                    const title = document.createElement('h3');
                    title.className = 'project-title';

                    // Add partner label based on 'under' field
                    let titleText = project.title || 'Untitled Project';
                    const under = project.under || 'Turfmapp';

                    if (under !== 'Turfmapp') {
                        titleText += ` - Partnered with ${under}`;
                    }

                    title.textContent = titleText;

                    // Make title clickable - opens project detail modal
                    title.style.cursor = 'pointer';
                    title.style.textDecoration = 'underline';
                    title.addEventListener('click', () => {
                        // Close mobile modal first
                        closeMobileModal();
                        // Open project detail modal
                        this.openProjectDetail(project, tooltipData.projects, projectIndex);
                    });

                    projectItem.appendChild(title);

                    // Add project description right after title
                    if (project.description) {
                        const description = document.createElement('p');
                        description.className = 'project-description';
                        description.textContent = project.description;
                        projectItem.appendChild(description);
                    }

                    // Display YouTube video if available (highest priority)
                    if (project.youtube_url) {
                        const mediaContainer = document.createElement('div');
                        mediaContainer.className = 'project-media';

                        const youtubeId = this.getYouTubeVideoId(project.youtube_url);
                        if (youtubeId) {
                            const iframe = document.createElement('iframe');
                            iframe.src = `https://www.youtube.com/embed/${youtubeId}`;
                            iframe.setAttribute('frameborder', '0');
                            iframe.setAttribute('allowfullscreen', '');
                            iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                            iframe.style.width = '100%';
                            iframe.style.height = '200px';
                            iframe.style.borderRadius = '8px';
                            mediaContainer.appendChild(iframe);

                            if (hasLink) {
                                mediaContainer.style.cursor = 'pointer';
                                mediaContainer.addEventListener('click', (e) => {
                                    if (e.target === mediaContainer) {
                                        window.open(project.links[0].url, '_blank', 'noopener,noreferrer');
                                    }
                                });
                            }

                            projectItem.appendChild(mediaContainer);
                        }
                    }

                    // Display all media from media array (new format)
                    if (project.media && Array.isArray(project.media) && project.media.length > 0) {
                        project.media.forEach(mediaItem => {
                            const mediaContainer = document.createElement('div');
                            mediaContainer.className = 'project-media';

                            if (mediaItem.type === 'video') {
                                const video = document.createElement('video');
                                video.src = mediaItem.url;
                                video.muted = true;
                                video.preload = 'metadata';
                                mediaContainer.appendChild(video);

                                mediaContainer.addEventListener('click', () => {
                                    // Close mobile modal and open project detail modal
                                    closeMobileModal();
                                    this.openProjectDetail(project, tooltipData.projects, projectIndex);
                                });
                            } else {
                                const img = document.createElement('img');
                                img.src = mediaItem.url;
                                img.alt = project.title;
                                mediaContainer.appendChild(img);

                                mediaContainer.addEventListener('click', () => {
                                    // Close mobile modal and open project detail modal
                                    closeMobileModal();
                                    this.openProjectDetail(project, tooltipData.projects, projectIndex);
                                });
                            }

                            projectItem.appendChild(mediaContainer);
                        });
                    } else if (project.image_url || project.video_url) {
                        // Fallback: Display single media (old format for backward compatibility)
                        const mediaContainer = document.createElement('div');
                        mediaContainer.className = 'project-media';

                        const mediaUrl = project.video_url || project.image_url;
                        const isVideo = !!project.video_url;

                        if (isVideo) {
                            const video = document.createElement('video');
                            video.src = mediaUrl;
                            video.muted = true;
                            video.preload = 'metadata';
                            mediaContainer.appendChild(video);

                            mediaContainer.addEventListener('click', () => {
                                // Close mobile modal and open project detail modal
                                closeMobileModal();
                                this.openProjectDetail(project, tooltipData.projects, projectIndex);
                            });
                        } else {
                            const img = document.createElement('img');
                            img.src = mediaUrl;
                            img.alt = project.title;
                            mediaContainer.appendChild(img);

                            mediaContainer.addEventListener('click', () => {
                                // Close mobile modal and open project detail modal
                                closeMobileModal();
                                this.openProjectDetail(project, tooltipData.projects, projectIndex);
                            });
                        }

                        projectItem.appendChild(mediaContainer);
                    }

                    // Add project links as text ONLY if there's no media
                    const hasMedia = project.youtube_url || (project.media && project.media.length > 0) || project.image_url || project.video_url;
                    if (!hasMedia && project.links && project.links.length > 0) {
                        const linksContainer = document.createElement('div');
                        linksContainer.className = 'project-links';

                        project.links.forEach(link => {
                            const linkEl = document.createElement('a');
                            linkEl.href = link.url;
                            linkEl.textContent = link.text;
                            linkEl.className = 'project-link';
                            linkEl.target = '_blank';
                            linkEl.rel = 'noopener noreferrer';
                            linksContainer.appendChild(linkEl);
                        });

                        projectItem.appendChild(linksContainer);
                    }

                    modalContent.appendChild(projectItem);
                });

                // Show modal
                backdrop.classList.add('visible');
                modal.classList.add('visible');

                // Disable camera movement
                this.disableMovement();

                // Prevent body scroll
                document.body.style.overflow = 'hidden';

                // Close handlers
                closeBtn.onclick = closeMobileModal;
                backdrop.onclick = closeMobileModal;
            }

            openVideoModal(videoUrl) {
                const modal = document.getElementById('videoModal');
                const video = document.getElementById('modalVideo');
                const source = document.getElementById('modalVideoSource');

                source.src = videoUrl;
                video.load(); // Reload the video element
                modal.classList.add('visible');

                // Auto-play the video
                video.play().catch(e => console.log('Auto-play prevented:', e));

                // Disable background movement
                this.disableMovement();
            }

            closeVideoModal() {
                const modal = document.getElementById('videoModal');
                const video = document.getElementById('modalVideo');

                modal.classList.remove('visible');
                video.pause();
                video.currentTime = 0;

                // Re-enable movement
                this.enableMovement();
            }

            openImagePage(project) {
                // For now, we'll create a simple image viewer page
                // In a real app, this might navigate to a dedicated project page
                const imageUrl = project.image_url;
                const newWindow = window.open('', '_blank');
                newWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>${project.title}</title>
                        <style>
                            body { 
                                margin: 0; 
                                background: #000; 
                                display: flex; 
                                justify-content: center; 
                                align-items: center; 
                                min-height: 100vh;
                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            }
                            .container {
                                max-width: 90vw;
                                max-height: 90vh;
                                text-align: center;
                                color: white;
                            }
                            img {
                                max-width: 100%;
                                max-height: 80vh;
                                object-fit: contain;
                                border-radius: 8px;
                                box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                            }
                            h1 {
                                margin-bottom: 20px;
                                font-size: 24px;
                            }
                            .description {
                                margin-top: 20px;
                                font-size: 16px;
                                opacity: 0.8;
                                max-width: 600px;
                                margin-left: auto;
                                margin-right: auto;
                                line-height: 1.6;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <h1>${project.title}</h1>
                            <img src="${imageUrl}" alt="${project.title}">
                            ${project.description ? `<div class="description">${project.description}</div>` : ''}
                        </div>
                    </body>
                    </html>
                `);
            }

            // Extract YouTube video ID from various URL formats
            getYouTubeVideoId(url) {
                if (!url) return null;

                // Support multiple YouTube URL formats
                const patterns = [
                    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                    /^([a-zA-Z0-9_-]{11})$/  // Direct video ID
                ];

                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1]) {
                        return match[1];
                    }
                }

                return null;
            }

            hideTooltip() {
                const tooltip = document.getElementById('projectTooltip');
                const connectionLine = document.getElementById('connectionLine');

                // Remove visible classes
                tooltip.classList.remove('visible');
                connectionLine.classList.remove('visible');

                // Clear any position classes
                tooltip.className = 'tooltip';

                // Reset connection line styles
                connectionLine.style.left = '';
                connectionLine.style.top = '';
                connectionLine.style.width = '';
                connectionLine.style.transform = '';

                // Re-enable movement when tooltip is hidden
                this.enableMovement();
                this.scene.classList.remove('tooltip-active');
            }

            disableMovement() {
                // Disable all camera movement when tooltip is active
                this.movementDisabled = true;
            }

            enableMovement() {
                // Only enable if no tooltip is visible and no hotspot is being hovered
                const tooltip = document.getElementById('projectTooltip');
                const hoveredHotspot = document.querySelector('.hotspot:hover');

                if (!tooltip.classList.contains('visible') && !hoveredHotspot) {
                    this.movementDisabled = false;
                }
            }

            showConnectionLine(hotspot, tooltip) {
                // Don't show connection lines on mobile
                if (this.isMobile) {
                    return;
                }

                const connectionLine = document.getElementById('connectionLine');

                // Ensure we wait for any ongoing transitions to settle
                setTimeout(() => {
                    // Force fresh layout calculation
                    tooltip.offsetHeight;
                    hotspot.offsetHeight;

                    // Get current positions after layout
                    const hotspotRect = hotspot.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();

                    // Validate rectangles
                    if (!hotspotRect.width || !tooltipRect.width) {
                        return;
                    }

                    // Get hotspot center
                    const hotspotCenterX = hotspotRect.left + (hotspotRect.width / 2);
                    const hotspotCenterY = hotspotRect.top + (hotspotRect.height / 2);

                    // Get tooltip connection point based on position
                    let tooltipConnectX, tooltipConnectY;
                    const tooltipClasses = tooltip.className;

                    if (tooltipClasses.includes('position-top')) {
                        tooltipConnectX = tooltipRect.left + (tooltipRect.width / 2);
                        tooltipConnectY = tooltipRect.bottom;
                    } else if (tooltipClasses.includes('position-bottom')) {
                        tooltipConnectX = tooltipRect.left + (tooltipRect.width / 2);
                        tooltipConnectY = tooltipRect.top;
                    } else if (tooltipClasses.includes('position-left')) {
                        tooltipConnectX = tooltipRect.right;
                        tooltipConnectY = tooltipRect.top + (tooltipRect.height / 2);
                    } else if (tooltipClasses.includes('position-right')) {
                        tooltipConnectX = tooltipRect.left;
                        tooltipConnectY = tooltipRect.top + (tooltipRect.height / 2);
                    } else {
                        tooltipConnectX = tooltipRect.left + (tooltipRect.width / 2);
                        tooltipConnectY = tooltipRect.top + (tooltipRect.height / 2);
                    }

                    // Calculate line properties
                    const deltaX = tooltipConnectX - hotspotCenterX;
                    const deltaY = tooltipConnectY - hotspotCenterY;
                    const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

                    // Set line properties
                    connectionLine.style.left = `${hotspotCenterX}px`;
                    connectionLine.style.top = `${hotspotCenterY}px`;
                    connectionLine.style.width = `${length}px`;
                    connectionLine.style.transform = `rotate(${angle}deg)`;
                    connectionLine.style.transformOrigin = '0 center';

                    // Show the line
                    connectionLine.classList.add('visible');
                }, 100);
            }

            positionTooltip(tooltip, hotspot) {
                const hotspotRect = hotspot.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                const viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };

                const spacing = 200;
                let position = 'top'; // default
                let left = hotspotRect.left + (hotspotRect.width / 2);
                let top = hotspotRect.top - tooltipRect.height - spacing;

                // Check if tooltip fits above hotspot
                if (top < spacing) {
                    // Position below
                    position = 'bottom';
                    top = hotspotRect.bottom + spacing;
                }

                // Check if tooltip fits to the right
                if (left + tooltipRect.width / 2 > viewport.width - spacing) {
                    // Position to the left
                    position = 'left';
                    left = hotspotRect.left - tooltipRect.width - spacing;
                    top = hotspotRect.top + (hotspotRect.height / 2) - (tooltipRect.height / 2);
                }

                // Check if tooltip fits to the left
                if (left - tooltipRect.width / 2 < spacing) {
                    // Position to the right
                    position = 'right';
                    left = hotspotRect.right + spacing;
                    top = hotspotRect.top + (hotspotRect.height / 2) - (tooltipRect.height / 2);
                }

                // Center tooltip for top/bottom positions
                if (position === 'top' || position === 'bottom') {
                    left = left - (tooltipRect.width / 2);

                    // Keep tooltip within viewport horizontally
                    if (left < spacing) left = spacing;
                    if (left + tooltipRect.width > viewport.width - spacing) {
                        left = viewport.width - tooltipRect.width - spacing;
                    }
                }

                // Keep tooltip within viewport vertically
                if (top < spacing) top = spacing;
                if (top + tooltipRect.height > viewport.height - spacing) {
                    top = viewport.height - tooltipRect.height - spacing;
                }

                // Apply position and class for arrow
                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
                tooltip.className = `tooltip position-${position}`;
            }


            updateDebugInfo() {
                if (!this.debugMode) return;

                const container = document.getElementById('debugContainer');
                const imageRect = document.getElementById('debugImageRect');
                const position = document.getElementById('debugPosition');
                const smooth = document.getElementById('debugSmooth');
                const mouse = document.getElementById('debugMouse');
                const edge = document.getElementById('debugEdge');

                // Debug info for camera system
                container.textContent = `Viewport: ${this.scene.clientWidth}x${this.scene.clientHeight}`;
                imageRect.textContent = `Image: ${Math.round(this.imageRect.width)}x${Math.round(this.imageRect.height)}`;
                position.textContent = `Camera: (${this.camera.targetX.toFixed(1)}, ${this.camera.targetY.toFixed(1)})`;
                smooth.textContent = `Limits: (${this.motionConfig.maxCameraX.toFixed(1)}, ${this.motionConfig.maxCameraY.toFixed(1)})`;
                mouse.textContent = `${this.edgeMovement.mouseX}, ${this.edgeMovement.mouseY}`;

                // Check if mouse is in edge zones
                const { mouseX, mouseY } = this.edgeMovement;
                const { edgeZone } = this.motionConfig;
                const vw = window.innerWidth;
                const vh = window.innerHeight;

                let edgeStatus = 'none';
                if (mouseX < edgeZone) edgeStatus += ' LEFT';
                if (mouseX > vw - edgeZone) edgeStatus += ' RIGHT';
                if (mouseY < edgeZone) edgeStatus += ' TOP';
                if (mouseY > vh - edgeZone) edgeStatus += ' BOTTOM';

                edge.textContent = edgeStatus === 'none' ? 'none' : edgeStatus.trim();
            }

            // Project Detail Modal Methods
            openProjectDetail(project, allProjects, projectIndex) {
                // Store state for navigation
                this.currentProjectDetail = {
                    project: project,
                    allProjects: allProjects,
                    projectIndex: projectIndex
                };

                // Get modal elements
                const backdrop = document.getElementById('projectDetailBackdrop');
                const modal = document.getElementById('projectDetailModal');

                // Populate modal content
                this.populateProjectDetail(project);

                // Show/hide navigation buttons based on position
                const prevBtn = document.getElementById('projectPrevBtn');
                const nextBtn = document.getElementById('projectNextBtn');

                prevBtn.style.display = projectIndex > 0 ? 'flex' : 'none';
                nextBtn.style.display = projectIndex < allProjects.length - 1 ? 'flex' : 'none';

                // Show modal
                backdrop.classList.add('visible');
                modal.classList.add('visible');

                // Disable camera movement
                this.disableMovement();

                // Prevent body scroll
                document.body.style.overflow = 'hidden';

                // Set up event listeners (only once)
                if (!this.projectDetailListenersAdded) {
                    this.setupProjectDetailListeners();
                    this.projectDetailListenersAdded = true;
                }
            }

            populateProjectDetail(project) {
                // Set title
                document.getElementById('projectDetailTitle').textContent = project.title || 'Untitled Project';

                // Set meta info
                document.getElementById('projectDetailClient').textContent = project.under || 'Turfmapp';
                document.getElementById('projectDetailService').textContent = project.service || '-';
                document.getElementById('projectDetailDate').textContent = project.date || '-';

                // Collect all media items
                const mediaItems = [];

                // Add YouTube video if available
                if (project.youtube_url) {
                    const youtubeId = this.getYouTubeVideoId(project.youtube_url);
                    if (youtubeId) {
                        mediaItems.push({
                            type: 'youtube',
                            id: youtubeId,
                            url: project.youtube_url
                        });
                    }
                }

                // Add media from media array
                if (project.media && Array.isArray(project.media)) {
                    project.media.forEach(item => {
                        mediaItems.push({
                            type: item.type,
                            url: item.url,
                            thumbnail: item.thumbnail
                        });
                    });
                }

                // Fallback: single image or video
                if (mediaItems.length === 0) {
                    if (project.video_url) {
                        mediaItems.push({
                            type: 'video',
                            url: project.video_url
                        });
                    } else if (project.image_url) {
                        mediaItems.push({
                            type: 'image',
                            url: project.image_url
                        });
                    }
                }

                // Populate Hero Section (first media item)
                const heroSection = document.getElementById('projectDetailHero');
                heroSection.innerHTML = '';

                if (mediaItems.length > 0) {
                    const heroMedia = document.createElement('div');
                    heroMedia.className = 'hero-media';

                    const firstItem = mediaItems[0];

                    if (firstItem.type === 'youtube') {
                        const iframe = document.createElement('iframe');
                        iframe.src = `https://www.youtube.com/embed/${firstItem.id}`;
                        iframe.setAttribute('frameborder', '0');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        heroMedia.appendChild(iframe);
                    } else if (firstItem.type === 'video') {
                        const video = document.createElement('video');
                        video.src = firstItem.url;
                        video.controls = true;
                        video.preload = 'metadata';
                        heroMedia.appendChild(video);
                    } else {
                        const img = document.createElement('img');
                        img.src = firstItem.url;
                        img.alt = project.title;
                        heroMedia.appendChild(img);
                    }

                    heroSection.appendChild(heroMedia);
                    heroSection.style.display = 'block';
                } else {
                    heroSection.style.display = 'none';
                }

                // Set description
                const descriptionSection = document.getElementById('projectDetailDescriptionSection');
                const descriptionEl = document.getElementById('projectDetailDescription');
                descriptionEl.textContent = project.description || 'No description available.';
                descriptionSection.style.display = project.description ? 'block' : 'none';

                // Populate Gallery (remaining media items)
                const gallery = document.getElementById('projectDetailGallery');
                gallery.innerHTML = '';

                // Render gallery items (skip first item as it's in hero)
                const galleryItems = mediaItems.slice(1);

                galleryItems.forEach((item, index) => {
                    const galleryItem = document.createElement('div');
                    galleryItem.className = 'gallery-item';

                    if (item.type === 'youtube') {
                        const iframe = document.createElement('iframe');
                        iframe.src = `https://www.youtube.com/embed/${item.id}`;
                        iframe.setAttribute('frameborder', '0');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        galleryItem.appendChild(iframe);
                        galleryItem.style.cursor = 'default';
                    } else if (item.type === 'video') {
                        const video = document.createElement('video');
                        video.src = item.url;
                        video.muted = true;
                        video.loop = true;
                        video.preload = 'metadata';
                        galleryItem.appendChild(video);

                        // Click to open in lightbox (index + 1 because we skipped first)
                        galleryItem.addEventListener('click', () => {
                            this.openLightbox(mediaItems, index + 1);
                        });
                    } else {
                        const img = document.createElement('img');
                        img.src = item.thumbnail || item.url;
                        img.alt = project.title;
                        img.loading = 'lazy';
                        galleryItem.appendChild(img);

                        // Click to open in lightbox (index + 1 because we skipped first)
                        galleryItem.addEventListener('click', () => {
                            this.openLightbox(mediaItems, index + 1);
                        });
                    }

                    gallery.appendChild(galleryItem);
                });

                // Hide gallery if no additional media
                gallery.style.display = galleryItems.length > 0 ? 'grid' : 'none';
            }

            setupGalleryParallax() {
                // Disabled parallax for cleaner Turfmapp-style layout
                // Images now display in full-width static format
            }

            closeProjectDetail() {
                const backdrop = document.getElementById('projectDetailBackdrop');
                const modal = document.getElementById('projectDetailModal');

                backdrop.classList.remove('visible');
                modal.classList.remove('visible');

                // Clear state
                this.currentProjectDetail = null;

                // Re-enable movement
                this.enableMovement();

                // Restore body scroll
                document.body.style.overflow = '';
            }

            navigateProject(direction) {
                if (!this.currentProjectDetail) return;

                const { allProjects, projectIndex } = this.currentProjectDetail;
                let newIndex = projectIndex;

                if (direction === 'prev' && projectIndex > 0) {
                    newIndex = projectIndex - 1;
                } else if (direction === 'next' && projectIndex < allProjects.length - 1) {
                    newIndex = projectIndex + 1;
                } else {
                    return; // No navigation needed
                }

                const newProject = allProjects[newIndex];
                this.currentProjectDetail.project = newProject;
                this.currentProjectDetail.projectIndex = newIndex;

                // Update modal content
                this.populateProjectDetail(newProject);

                // Update navigation buttons visibility
                const prevBtn = document.getElementById('projectPrevBtn');
                const nextBtn = document.getElementById('projectNextBtn');

                prevBtn.style.display = newIndex > 0 ? 'flex' : 'none';
                nextBtn.style.display = newIndex < allProjects.length - 1 ? 'flex' : 'none';

                // Scroll to top of modal
                document.getElementById('projectDetailModal').scrollTop = 0;
            }

            setupProjectDetailListeners() {
                // Close button
                document.getElementById('projectDetailClose').addEventListener('click', () => {
                    this.closeProjectDetail();
                });

                // Backdrop click
                document.getElementById('projectDetailBackdrop').addEventListener('click', () => {
                    this.closeProjectDetail();
                });

                // Navigation buttons
                document.getElementById('projectPrevBtn').addEventListener('click', () => {
                    this.navigateProject('prev');
                });

                document.getElementById('projectNextBtn').addEventListener('click', () => {
                    this.navigateProject('next');
                });

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Only handle if project detail is visible
                    const modal = document.getElementById('projectDetailModal');
                    if (!modal.classList.contains('visible')) return;

                    // Don't handle if lightbox is open
                    const lightbox = document.getElementById('lightbox');
                    if (lightbox && lightbox.classList.contains('visible')) return;

                    if (e.key === 'Escape') {
                        this.closeProjectDetail();
                    } else if (e.key === 'ArrowLeft') {
                        this.navigateProject('prev');
                    } else if (e.key === 'ArrowRight') {
                        this.navigateProject('next');
                    }
                });
            }

            // Lightbox Methods
            openLightbox(mediaItems, startIndex) {
                // Filter out YouTube items for lightbox (they don't work well in lightbox)
                const lightboxMedia = mediaItems.filter(item => item.type !== 'youtube');

                if (lightboxMedia.length === 0) return;

                // Adjust start index after filtering
                let adjustedIndex = startIndex;
                for (let i = 0; i < startIndex; i++) {
                    if (mediaItems[i].type === 'youtube') {
                        adjustedIndex--;
                    }
                }
                adjustedIndex = Math.max(0, Math.min(adjustedIndex, lightboxMedia.length - 1));

                // Store state
                this.currentLightbox = {
                    mediaItems: lightboxMedia,
                    currentIndex: adjustedIndex
                };

                // Show lightbox
                const backdrop = document.getElementById('lightboxBackdrop');
                const lightbox = document.getElementById('lightbox');

                backdrop.classList.add('visible');
                lightbox.classList.add('visible');

                // Display current media
                this.displayLightboxMedia();

                // Set up event listeners (only once)
                if (!this.lightboxListenersAdded) {
                    this.setupLightboxListeners();
                    this.lightboxListenersAdded = true;
                }
            }

            displayLightboxMedia() {
                if (!this.currentLightbox) return;

                const { mediaItems, currentIndex } = this.currentLightbox;
                const item = mediaItems[currentIndex];
                const content = document.getElementById('lightboxContent');

                // Clear content
                content.innerHTML = '';

                // Create media element
                if (item.type === 'video') {
                    const video = document.createElement('video');
                    video.src = item.url;
                    video.controls = true;
                    video.autoplay = true;
                    video.style.maxWidth = '90vw';
                    video.style.maxHeight = '90vh';
                    video.style.objectFit = 'contain';
                    content.appendChild(video);
                } else {
                    const img = document.createElement('img');
                    img.src = item.url;
                    img.alt = 'Project media';
                    img.style.maxWidth = '90vw';
                    img.style.maxHeight = '90vh';
                    img.style.objectFit = 'contain';
                    content.appendChild(img);
                }

                // Update navigation button visibility
                const prevBtn = document.getElementById('lightboxPrev');
                const nextBtn = document.getElementById('lightboxNext');

                prevBtn.style.display = currentIndex > 0 ? 'flex' : 'none';
                nextBtn.style.display = currentIndex < mediaItems.length - 1 ? 'flex' : 'none';
            }

            closeLightbox() {
                const backdrop = document.getElementById('lightboxBackdrop');
                const lightbox = document.getElementById('lightbox');

                backdrop.classList.remove('visible');
                lightbox.classList.remove('visible');

                // Clear content
                document.getElementById('lightboxContent').innerHTML = '';

                // Clear state
                this.currentLightbox = null;
            }

            navigateLightbox(direction) {
                if (!this.currentLightbox) return;

                const { mediaItems, currentIndex } = this.currentLightbox;
                let newIndex = currentIndex;

                if (direction === 'prev' && currentIndex > 0) {
                    newIndex = currentIndex - 1;
                } else if (direction === 'next' && currentIndex < mediaItems.length - 1) {
                    newIndex = currentIndex + 1;
                } else {
                    return; // No navigation needed
                }

                this.currentLightbox.currentIndex = newIndex;
                this.displayLightboxMedia();
            }

            setupLightboxListeners() {
                // Close button
                document.getElementById('lightboxClose').addEventListener('click', () => {
                    this.closeLightbox();
                });

                // Backdrop click
                document.getElementById('lightboxBackdrop').addEventListener('click', () => {
                    this.closeLightbox();
                });

                // Navigation buttons
                document.getElementById('lightboxPrev').addEventListener('click', () => {
                    this.navigateLightbox('prev');
                });

                document.getElementById('lightboxNext').addEventListener('click', () => {
                    this.navigateLightbox('next');
                });

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Only handle if lightbox is visible
                    const lightbox = document.getElementById('lightbox');
                    if (!lightbox.classList.contains('visible')) return;

                    if (e.key === 'Escape') {
                        this.closeLightbox();
                    } else if (e.key === 'ArrowLeft') {
                        this.navigateLightbox('prev');
                    } else if (e.key === 'ArrowRight') {
                        this.navigateLightbox('next');
                    }
                });
            }
        }

        // Initialize the camera controller when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new CameraController();
        });

        // Accessibility: Announce to screen readers
        const announcement = document.createElement('div');
        announcement.className = 'sr-only';
        announcement.setAttribute('aria-live', 'polite');
        announcement.textContent = 'Interactive portfolio hero loaded. Use tab to navigate to project hotspots.';
        document.body.appendChild(announcement);
    </script>
</body>

</html>